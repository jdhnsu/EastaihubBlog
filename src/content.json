{
  "posts": [
    {
      "slug": "Python_Manage",
      "title": "Python 项目管理入门",
      "date": "2025-10-10T11:02:53.000Z",
      "tags": [
        "计算机基础"
      ],
      "excerpt": " Python 项目管理入门\r\n> 这是一篇面向新加入实验室的同学撰写的 Python 项目管理入门教程。\r\n\r\n做项目就像养一棵树：种下源码（seed），逐步施肥（依赖、测试、CI），最终收获果实（可交付的软件）。缺少项目管理，你的代码会像杂草丛生——依赖冲突、环境不可复现、部署反复失败。良好的项目管理能让你在学术或工程项目中更快地复现结果、共享环境、定位问题，也能让团队协作更顺畅。\r\n\r\n本...",
      "content": "<h1>Python 项目管理入门</h1>\n<blockquote>\n<p>这是一篇面向新加入实验室的同学撰写的 Python 项目管理入门教程。</p>\n</blockquote>\n<p>做项目就像养一棵树：种下源码（seed），逐步施肥（依赖、测试、CI），最终收获果实（可交付的软件）。缺少项目管理，你的代码会像杂草丛生——依赖冲突、环境不可复现、部署反复失败。良好的项目管理能让你在学术或工程项目中更快地复现结果、共享环境、定位问题，也能让团队协作更顺畅。</p>\n<p>本指南采用实用为主的风格，按常见工具流派拆解：社区标准（pip + venv）、科学与二进制包友好（Conda），以及现代化的依赖与发布工具（Poetry）。每一节都包含命令示例、优劣对比与常见陷阱。</p>\n<h2>小契约（Contract）</h2>\n<ul>\n<li>输入：开发者希望在任意机器上复现 Python 环境并运行项目。</li>\n<li>输出：可复现的依赖清单、可切换的隔离环境、常用命令速查表。</li>\n<li>错误模式：依赖冲突、平台差异（Windows/Linux/macOS）、二进制包缺失、网络/镜像问题。</li>\n</ul>\n<h2>常见的边界情况（Edge cases）</h2>\n<ul>\n<li>需要二进制扩展（例如 numpy、pandas、scipy）且目标机器无编译环境。</li>\n<li>同时需要多个 Python 版本（如 3.8 与 3.11）。</li>\n<li>CI 与生产环境使用不同的包源或私有包。</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>实验室一般使用<code>conda</code>作为学习和开发的主要工具</strong></p>\n</blockquote>\n<h2>工具一：pip + venv（Python 社区的基础方案）</h2>\n<blockquote>\n<p>最轻量、与标准库最贴近的方案。推荐用于小型项目、脚本、教学以及对二进制依赖要求不高的场景。</p>\n</blockquote>\n<p>为什么选它：pip 和 venv 是 Python 标准工具（无需额外安装 Python3 自带 venv），它易于理解、与大多数托管平台（比如 PyPI）兼容。</p>\n<p>如何工作（简短流程）：</p>\n<ol>\n<li>创建虚拟环境（隔离 site-packages）。</li>\n<li>激活环境并安装依赖（pip install）。</li>\n<li>导出依赖（requirements.txt）以便复现。</li>\n</ol>\n<p>快速上手（Windows pwsh 示例）：</p>\n<pre><code class=\"language-powershell\"># 创建虚拟环境（只需一次）\npython -m venv .venv\n\n# 激活（PowerShell）\n.\\.venv\\Scripts\\Activate.ps1\n\n# 安装依赖\npip install requests flask\n\n# 将当前环境依赖导出为 requirements.txt\npip freeze &gt; requirements.txt\n\n# 在另一台机器上复现\npython -m venv .venv\n.\\.venv\\Scripts\\Activate.ps1\npip install -r requirements.txt\n</code></pre>\n<p>实用技巧与陷阱：</p>\n<ul>\n<li>windows 下不要把虚拟环境放在 PATH 很深的目录，避免路径长度问题。</li>\n<li>使用 <code>python -m pip</code> 而不是直接 <code>pip</code> 可以减少版本错配（确保使用当前 Python 的 pip）。</li>\n<li><code>pip freeze</code> 会将所有已安装包固定到具体版本，适合生产或 CI；开发时可只维护 <code>requirements.in</code> 并通过 <code>pip-compile</code> 生成锁文件（见下）。</li>\n<li>对于需要编译的二进制扩展，Windows/macOS 可能缺少编译器，这时考虑使用 wheels 或切换到 Conda。</li>\n</ul>\n<p>验收标准：能在干净机器上通过 <code>requirements.txt</code> 完整安装并运行项目的最小示例。</p>\n<hr>\n<h2>工具二：Conda（适合科学计算与二进制包）</h2>\n<blockquote>\n<p>Conda 是一个跨语言的包和环境管理器，擅长分发预编译的二进制包（尤其是科学栈），常用于数据科学和科研环境。</p>\n</blockquote>\n<p>为什么选它：当你的项目依赖如 numpy、scipy、pandas、opencv 等大型二进制包时，Conda 能避免本地编译，直接安装兼容的二进制文件。</p>\n<h3>conda 安装</h3>\n<p>一般直接从官网(<a href=\"https://www.anaconda.com/download\">anaconda.com</a>)直接下载安装包安装即可，安装后可通过 <code>conda --version</code> 验证是否安装成功。但是有时受限于网络环境问题下载速度缓慢，可以考虑从清华源下载安装包。</p>\n<ul>\n<li><p>1.打开<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/\">清华源conda-help</a></p>\n</li>\n<li><p>2.打开<a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> 下载合适版本的安装包(建议使用 <code>Anaconda3-2025.06-1-Windows/Linux/MacOS-x86_64.sh/exe/pkg</code> 版本，避免一些列的版本问题)</p>\n<blockquote>\n<p>对于windows系统，下载后直接双击运行安装包即可，安装路径默认即可。然后：</p>\n<ul>\n<li>打开 <code>控制面板</code> -&gt; <code>系统和安全</code> -&gt; <code>系统</code> -&gt; <code>高级系统设置</code> -&gt; <code>高级</code> -&gt; <code>环境变量</code> -&gt; <code>系统变量</code> -&gt; <code>Path</code></li>\n<li>编辑 <code>Path</code> 变量，在末尾添加 <code>C:\\Users\\用户名\\Anaconda3;C:\\Users\\用户名\\Anaconda3\\Scripts;C:\\Users\\用户名\\Anaconda3\\Library\\bin;</code>\n如果你没有安装到默认路径，请自行修改上述路径。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>将conda的软件的下载源也换到清华源：</p>\n<ul>\n<li><p>Windows：打开<code>C:\\Users\\&lt;YourUserName&gt;\\.condarc</code>, 添加与linux/macos相同的内容。</p>\n</li>\n<li><p>Linux/MacOS：打开 <code>~/.condarc</code> 文件，添加以下内容：</p>\n<pre><code class=\"language-bash\">channels:\n    - defaults\nshow_channel_urls: true\ndefault_channels:\n    - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n    - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n    - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n    conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n    pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>基础使用示例（Miniconda/Anaconda）：</p>\n<pre><code class=\"language-bash\"># 创建并指定 Python 版本\nconda create -n myenv python=3.10\n\n# 激活环境\nconda activate myenv\n\n# 安装包（来自默认 channel 或 conda-forge）\nconda install numpy pandas\n\n# 导出环境到 yml（包含依赖与 Python 版本）\nconda env export --no-builds &gt; environment.yml\n\n# 在另一台机器上复现\nconda env create -f environment.yml\nconda activate myenv\n</code></pre>\n<p>优点：</p>\n<ul>\n<li>预编译二进制包，避免编译工具链问题。</li>\n<li>可以管理非 Python 依赖（如 libpng、openblas）。</li>\n<li>适配跨平台科学栈，conda-forge 社区活跃。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>Conda 环境通常较大，占用磁盘多。</li>\n<li>有时包版本落后于 PyPI，或出现依赖冲突解析较慢。</li>\n<li>与 pip 的互操作需要小心：不要在 base 环境中混用，优先在独立环境内使用 <code>pip</code> 或 <code>conda</code>。</li>\n</ul>\n<p>常见陷阱与建议：</p>\n<ul>\n<li>优先在新建的 conda 环境内用 <code>conda install</code> 安装能从 conda 获得的包；仅当 conda 无包时使用 <code>pip</code>。</li>\n<li>使用 <code>conda env export --no-builds</code> 可以得到更可移植的 yml 文件。</li>\n<li>在 CI 中使用 miniconda 镜像或 mambaforge（mamba 的 conda 替代实现）以加快解析速度：<code>mamba create -n myenv python=3.10 numpy</code>。</li>\n</ul>\n<p>验收标准：在 CI 或目标机器上通过 <code>environment.yml</code> 重建环境并运行关键测试。</p>\n<hr>\n<h2>工具三：Poetry（现代化项目与依赖管理）</h2>\n<p>为什么选它：Poetry 把依赖管理（pyproject.toml）和版本解析、发布流程结合到一起，支持 lock 文件（poetry.lock），便于在团队与 CI 间复制精确依赖树。</p>\n<p>快速上手：</p>\n<pre><code class=\"language-bash\"># 安装（建议使用官方脚本或包管理器）\ncurl -sSL https://install.python-poetry.org | python -\n\n# 在项目根目录初始化\npoetry init\n\n# 添加依赖并自动创建虚拟环境\npoetry add requests\n\n# 运行命令（在 Poetry 管理的虚拟环境中）\npoetry run python -m mymodule\n\n# 导出 requirements（必要时用于 Docker/CI）\npoetry export -f requirements.txt --output requirements.txt --without-hashes\n</code></pre>\n<p>优点：</p>\n<ul>\n<li>将项目配置集中到 <code>pyproject.toml</code>（PEP 621），现代、标准化。</li>\n<li>自动生成并维护锁文件，便于复现。</li>\n<li>集成发布（poetry publish）到 PyPI。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>对于依赖需要 conda 二进制包的科学栈，并不是最佳选择（仍可与 conda 混用，但需谨慎）。</li>\n<li>学习曲线比 pip+venv 略陡，需要理解 pyproject 与虚拟环境的隐式管理。</li>\n</ul>\n<p>建议用法：</p>\n<ul>\n<li>使用 Poetry 管理库或应用的依赖与打包发布流程。</li>\n<li>在 Dockerfile 中可将 poetry 导出的 requirements.txt 与官方 Python 镜像结合，以减少运行时依赖差异。</li>\n</ul>\n<p>验收标准：通过 <code>poetry install</code> 在干净环境中重现开发环境，并能通过 <code>poetry run pytest</code> 运行测试套件。</p>\n<hr>\n<h2>工具四：uv（一体化的极速项目管理工具）</h2>\n<blockquote>\n<p>如果你在寻找一个把 <code>pip</code>、<code>pip-tools</code>、<code>pipx</code>、<code>poetry</code>、<code>pyenv</code>、<code>virtualenv</code> 等功能集合到一个命令行工具里的现代方案，<code>uv</code> 值得了解。它由 Astral 团队开发（同样的团队开发了 Ruff），以速度和一体化特性为亮点。</p>\n</blockquote>\n<p>核心亮点（简述）：</p>\n<ul>\n<li>一体化：项目管理、脚本运行、工具安装、Python 版本管理与 pip 兼容接口都被覆盖。</li>\n<li>极速：官方基准显示在很多场景下比传统 pip 快 10-100 倍（受益于 Rust 实现与全局缓存）。</li>\n<li>工作区与锁文件：支持类似 Cargo 的工作区、多项目管理与通用锁文件，方便大型工程或 monorepo。</li>\n</ul>\n<p>快速上手与安装：</p>\n<pre><code class=\"language-bash\"># 官方安装脚本（macOS / Linux）\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows 或通过 pip/homebrew 安装参考官方文档\n</code></pre>\n<p>项目管理示例：</p>\n<pre><code class=\"language-bash\"># 初始化项目\nuv init example\ncd example\n\n# 添加依赖（会自动创建 .venv）\nuv add ruff\n\n# 运行已安装的工具或脚本\nuv run ruff check\n\n# 锁定与同步依赖\nuv lock\nuv sync\n</code></pre>\n<p>脚本管理（单文件依赖声明）：</p>\n<pre><code class=\"language-bash\"># 在脚本中使用内联元数据并安装运行\necho &#39;import requests; print(requests.get(&quot;https://astral.sh&quot;))&#39; &gt; example.py\nuv add --script example.py requests\nuv run example.py\n</code></pre>\n<p>工具安装与临时运行（类似 pipx）：</p>\n<pre><code class=\"language-bash\"># 临时运行\nuvx pycowsay &#39;hello world!&#39;\n\n# 安装工具到 uv 管理的全局工具位置\nuv tool install ruff\nruff --version\n</code></pre>\n<p>Python 版本管理：</p>\n<pre><code class=\"language-bash\"># 安装并切换 Python 版本\nuv python install 3.10 3.11 3.12\nuv venv --python 3.12.0\nuv python pin 3.11\n</code></pre>\n<p>pip 兼容接口：</p>\n<pre><code class=\"language-bash\"># 使用 uv 的 pip 接口进行更快的解析与安装\nuv pip sync docs/requirements.txt\nuv pip compile docs/requirements.in --universal --output-file docs/requirements.txt\n</code></pre>\n<p>优点与适用场景：</p>\n<ul>\n<li>如果你想要一个单一工具覆盖依赖解析、虚拟环境管理、Python 版本管理与工具执行，<code>uv</code> 是很好的选择。</li>\n<li>对于需要频繁安装/切换依赖、在 CI 中追求速度或管理大型 monorepo，uv 的全局缓存与并行化解析非常有吸引力。</li>\n</ul>\n<p>局限与注意事项：</p>\n<ul>\n<li>新兴工具：虽然功能强大且在快速发展，但生态与社区规模尚不及 pip/conda/poetry 那般成熟，遇到极端兼容问题时可能需要更多排查。</li>\n<li>与 Conda 的二进制包管理（尤其科学栈）并不总是直接互换；对大量依赖本地编译或特定二进制的项目仍建议使用 Conda。</li>\n</ul>\n<p>迁移建议：</p>\n<ul>\n<li>从 pip/venv 或 Poetry 迁移到 uv：先在沙盒分支中试验 <code>uv init</code> + <code>uv add</code>，使用 <code>uv lock</code> 生成锁并在 CI 中尝试 <code>uv sync</code>。</li>\n<li>在需要 conda 二进制包的项目中，可只在运行与构建阶段继续使用 Conda，而用 uv 管理 Python 级别的依赖与工具执行。</li>\n</ul>\n<p>参考与延伸阅读：</p>\n<ul>\n<li>uv 中文文档: <a href=\"https://uv.doczh.com/\">https://uv.doczh.com/</a></li>\n<li>uv 官方仓库: <a href=\"https://github.com/astral-sh/uv\">https://github.com/astral-sh/uv</a></li>\n</ul>\n<h2>作者注</h2>\n<p>对于新手来说我建议先入门使用 <code>pip+venv</code>，熟悉其基本用法，然后再尝试使用<code>uv</code>，因为 <code>pip+venv</code>  代表了传统的 Python 包管理方式，并且和<code>python</code>的设计哲学更贴近，有利于学习和理解<code>python</code>,而<code>uv</code>则是一款新型的工具,它代表者一种全新的思维方式,它将包管理、虚拟环境、Python版本管理、工具管理等功能集合到一个命令行工具中,并且它还提供了极速的依赖解析、全局缓存、并行化解析等特性，至于<code>poetry</code>，它和<code>uv</code>一样都是新的思维采用了<code>pyproject.toml</code>作为配置文件，所以没必要了解过多重复内容，当你因为一个项目接触到时，只需要简单了解即可快速上手。</p>\n<p>当你开始学习本实验室相关的AI项目时，那么你就可以开始学习<code>conda</code>的项目管理了，因为<code>conda</code>可以管理非 Python 依赖，并且它是跨平台的，适合科学计算与二进制包，对于一些需要<code>c/c++</code>加速的库来说，<code>conda</code>是最好的选择，并且<code>conda</code>不仅仅支持于<code>python</code>的开发项目，对于一些主流语言都具备完成的项目管理流程。</p>\n<p>通过这样一步一步的了解和学习，你才能不受限于工具本身的限制，在学习中不被工具本身困扰，在实践中游刃有余。</p>\n<blockquote>\n<p>本文和git于shell篇不同，本文主要由AI撰写，文章比较死板，所以建议多看看文章中链接的官方文档。</p>\n<blockquote>\n<p>作为一名计算机学习者，学会根据不同场景选择合适的工具至关重要，它能够显著提升工作效率。同时，强大的搜索能力和文档阅读技巧也极为重要。</p>\n</blockquote>\n</blockquote>\n<h2>实用最佳实践（适用于所有工具）</h2>\n<ul>\n<li>将依赖区分为运行时依赖和开发依赖（例如：test、lint、type-check 工具）。Poetry/conda 都支持分组，pip 可用 requirements-dev.txt。</li>\n<li>在 CI 中优先使用明确的 Python 版本与镜像（例如 <code>python:3.10-slim</code>）。</li>\n<li>把虚拟环境放在 .venv（项目内）并加入 .gitignore；这样更易于管理与激活。</li>\n<li>使用私有镜像或内部索引来加速企业内部包安装。国内用户可配置 PyPI 镜像（如清华、阿里云镜像）。</li>\n<li>定期更新依赖并在 CI 中运行安全扫描（如 pip-audit、safety、Bandit）。</li>\n</ul>\n<p>示例 .gitignore（最小）:</p>\n<pre><code>.venv/\n__pycache__/\n*.pyc\ndist/\nbuild/\n*.egg-info\n</code></pre>\n<p>CI 示例（GitHub Actions 简要片段，用 poetry）:</p>\n<pre><code class=\"language-yaml\">jobs:\n    test:\n        runs-on: ubuntu-latest\n        steps:\n            - uses: actions/checkout@v4\n            - name: Set up Python\n                uses: actions/setup-python@v4\n                with:\n                    python-version: &#39;3.10&#39;\n            - name: Install Poetry\n                run: curl -sSL https://install.python-poetry.org | python -\n            - name: Install dependencies\n                run: poetry install\n            - name: Run tests\n                run: poetry run pytest -q\n</code></pre>\n<hr>\n<h2>进阶话题与迁移建议</h2>\n<ul>\n<li>从 requirements.txt 迁移到 Poetry：逐步迁移，先在新分支中用 <code>poetry init</code>，手动把依赖填入 <code>pyproject.toml</code>，使用 <code>poetry lock</code> 生成锁文件，CI 中采用 <code>poetry install --no-dev</code> 进行生产部署。</li>\n<li>在需要大量二进制包的项目中，优先使用 Conda（或 mamba）创建运行环境，将 Python 源代码与依赖的二进制组件分开管理。</li>\n<li>对于包的发布与版本策略，推荐语义化版本（SemVer），并在 CI 中加入自动发布的保护（tag、签名、审核）。</li>\n</ul>\n<hr>\n<h2>常用命令速查表</h2>\n<ul>\n<li>创建 venv: <code>python -m venv .venv</code></li>\n<li>激活（Windows PowerShell）: <code>.\\.venv\\Scripts\\Activate.ps1</code></li>\n<li>导出 requirements: <code>pip freeze &gt; requirements.txt</code></li>\n<li>Conda 导出: <code>conda env export --no-builds &gt; environment.yml</code></li>\n</ul>\n<hr>\n<h2>参考与延伸阅读</h2>\n<ul>\n<li>pip 官方文档: <a href=\"https://pip.pypa.io/\">https://pip.pypa.io/</a></li>\n<li>Python Packaging User Guide: <a href=\"https://packaging.python.org/\">https://packaging.python.org/</a></li>\n<li>Poetry: <a href=\"https://python-poetry.org/\">https://python-poetry.org/</a></li>\n<li>Conda: <a href=\"https://docs.conda.io/\">https://docs.conda.io/</a></li>\n<li>uv: <a href=\"https://github.com/astral-sh/uv\">https://github.com/astral-sh/uv</a></li>\n<li>conda 还有很多衍生，如 <a href=\"https://conda-forge.org/\">conda-forge</a> 镜像，<a href=\"https://github.com/mamba-org/mamba\">mamba</a> 与 <a href=\"https://github.com/mamba-org/micromamba\">micromamba</a> 更快速的包管理器。</li>\n</ul>\n"
    },
    {
      "slug": "markdown",
      "title": "Markdown 快速入门",
      "date": "2025-10-09T11:02:53.000Z",
      "tags": [
        "计算机基础"
      ],
      "excerpt": " Markdown 快速入门\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。Markdown 的语法简洁，学习起来也很容易.\n\n> 这是一篇面向新加入实验室的同学撰写的计算机常用工具入门教程之Markdown.\n\n在计算机以及互联网领域的从业者的学习和工作中，无论是前端还是后端工程Markdown都是必备的工具。本文将介绍...",
      "content": "<h1>Markdown 快速入门</h1>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。Markdown 的语法简洁，学习起来也很容易.</p>\n<blockquote>\n<p>这是一篇面向新加入实验室的同学撰写的计算机常用工具入门教程之Markdown.</p>\n</blockquote>\n<p>在计算机以及互联网领域的从业者的学习和工作中，无论是前端还是后端工程Markdown都是必备的工具。本文将介绍 Markdown 的基本语法，并通过实例介绍 Markdown 的常用功能.</p>\n<h2>1.Markdown 于 HTML 的区别</h2>\n<p>MD和HTML都是标记语言，本质我认为没有什么区别，都是特定的标记符号来标记文本的结构和格式，并且我们一般所看到的MD文档都是经过渲染后的HTML文档.</p>\n<p>MD的语法更加简单，更加易读易写，并且可以直接转换成HTML，所以在写MD文档的时候，我们可以更加专注于内容的创作，而且MD到HTML的转换过程相对简单，如果有兴趣可以自己尝试使用<code>Python</code> ,<code>CPP</code> 等语言的标准库实现一个简单的<code>MD编译器</code>.</p>\n<h2>2.Markdown 文字语法</h2>\n<h4>1. 标题</h4>\n<pre><code># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre>\n<h4>2. 强调</h4>\n<pre><code>*斜体*\n_斜体_\n**粗体**\n__粗体__\n</code></pre>\n<blockquote>\n<p> <em>斜体</em>、<em>斜体</em>、<strong>粗体</strong>、<strong>粗体</strong></p>\n</blockquote>\n<h4>3. 引用</h4>\n<pre><code>&gt; 这是一个引用\n</code></pre>\n<blockquote>\n<p> 这是一个引用</p>\n</blockquote>\n<h4>4. 列表</h4>\n<ul>\n<li>无序列列表</li>\n</ul>\n<pre><code>- 列表1\n- 列表2\n- 列表3\n</code></pre>\n<ul>\n<li>有序列表</li>\n</ul>\n<pre><code>2. 列表1\n3. 列表2\n4. 列表3\n</code></pre>\n<ul>\n<li>嵌套列表</li>\n</ul>\n<pre><code>- 列表1\n  - 列表1.2\n- 列表2\n  - 列表2.1\n      - 列表2.1.1\n  - 列表2.2\n      - 列表2.2.1\n</code></pre>\n<blockquote>\n<ul>\n<li>无序列列表</li>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ul>\n</blockquote>\n<h4>5. <code>\\</code> 转义字符</h4>\n<ul>\n<li>反斜杠<code>\\</code>用来转义Markdown语法中的特殊字符，比如<code>\\*</code>表示星号，<code>\\|</code>表示竖线等。</li>\n<li>示例：</li>\n</ul>\n<pre><code>\\*斜体\\*\n</code></pre>\n<p><strong>效果</strong>: *斜体*</p>\n<h2>3. Markdown 文件与链接语法</h2>\n<h4>1. 链接</h4>\n<ul>\n<li>行内式：</li>\n</ul>\n<pre><code>[链接名称](链接地址)\n[eastaihub.cloud](https://eastaihub.cloud/)\n</code></pre>\n<blockquote>\n<p> <a href=\"https://eastaihub.cloud/\">eastaihub.cloud</a></p>\n</blockquote>\n<ul>\n<li>参考式：</li>\n</ul>\n<pre><code>[链接名称][1]\n\n [1]: 链接地址\n</code></pre>\n<h4>2. 图片</h4>\n<ul>\n<li>行内式：</li>\n</ul>\n<pre><code>![图片名称](图片地址)\n</code></pre>\n<ul>\n<li>参考式：</li>\n</ul>\n<pre><code>![图片名称][2]\n\n[2]: 图片地址 &quot;可选的标题文字&quot;\n</code></pre>\n<h4>3. 代码块</h4>\n<ul>\n<li>行内式：</li>\n</ul>\n<pre><code>`代码内容`\n</code></pre>\n<ul>\n<li>代码块：</li>\n</ul>\n<pre><code>``` 代码语言\n代码内容\n\n```cpp\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;\n    return 0;\n}\n\n\n```python\nprint(&quot;Hello, world!&quot;)\n</code></pre>\n<pre><code>\n</code></pre>\n<pre><code>\n```python\nprint(&quot;Hello, world!&quot;)\n</code></pre>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<h2>4.工具推荐</h2>\n<ul>\n<li><a href=\"https://typoraio.cn/\">Typora</a><blockquote>\n<p>商业软件（非开源）,全网目前风评较高的MD编辑器</p>\n</blockquote>\n</li>\n<li><a href=\"https://code.visualstudio.com/\">VS Code</a><blockquote>\n<p>免费开源的编辑器，支持MD语法高亮，插件丰富，功能强大,<em>推荐使用</em>,并且推荐一个MD插件<a href=\"https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced\">markdown-preview-enhanced</a>,这个插件支持xaringan、reveal.js、markdown-it等多种渲染方式，可以很方便地将MD文件渲染成HTML、PDF、PPT等格式,并且用起来比一些商业软件更加顺手,并且比其它部分启动更快,但是不支持所见即所得的预览模式.</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>大家可以使用 <a href=\"https://commonmark.org/help/\">commonmark.org</a>10分钟快速入门Markdown语法</p>\n</blockquote>\n"
    },
    {
      "slug": "Git使用入门",
      "title": "Git版本控制核心原理与操作指南",
      "date": "2025-10-08T11:02:53.000Z",
      "tags": [
        "计算机基础"
      ],
      "excerpt": "\r\n Git的模型与基础操作\r\n\r\n> 这是一篇面向新加入实验室的同学撰写的计算机常用工具入门教程之Git。作为一名计算机学习者，学会根据不同场景选择合适的工具至关重要，它能够显著提升工作效率。同时，强大的搜索能力和文档阅读技巧也极为重要。\r\n\r\nGit是一款版本控制工具，这类工具主要用于追踪源代码、文件或文件夹的变化。使用Git可以轻松地对代码进行回溯等操作。特别是在团队协作中，Git尤为便捷...",
      "content": "<h1>Git的模型与基础操作</h1>\n<blockquote>\n<p>这是一篇面向新加入实验室的同学撰写的计算机常用工具入门教程之Git。作为一名计算机学习者，学会根据不同场景选择合适的工具至关重要，它能够显著提升工作效率。同时，强大的搜索能力和文档阅读技巧也极为重要。</p>\n</blockquote>\n<p>Git是一款版本控制工具，这类工具主要用于追踪源代码、文件或文件夹的变化。使用Git可以轻松地对代码进行回溯等操作。特别是在团队协作中，Git尤为便捷：每位贡献者的代码都能被打上标签并保存其个人信息，便于后续的代码管理。此外，由于Git采用分布式架构，每位开发人员均可在本地完整存储源代码副本。不仅如此，Git还集成了分支管理和冲突解决方案等多项功能。</p>\n<h2>快照</h2>\n<p>如同一台相机，Git能够捕捉到当前项目的整体状态（涵盖所有文件夹及子目录），生成一份详尽的“照片”。一旦需要查看历史记录中的某个特定时刻的状态，只需定位至相应的快照即可获取当时完整的项目视图，其中包括了具体的作者信息与提交详情。为了高效利用空间资源，针对未曾变动过的数据部分，则通过指针机制直接指向先前版本的数据块来实现节约大量存储的目的。</p>\n<hr>\n<p><strong>在git的专业术语中</strong>: 文件被称为blob，文件夹被称为tree。</p>\n<h3>例如:</h3>\n<pre><code class=\"language-bash\">&lt;root&gt; (tree)\n|\n+- foo (tree)\n|  |\n|  + bar.txt (blob, contents = &quot;hello world&quot;)\n|\n+- baz.txt (blob, contents = &quot;git is wonderful&quot;)\n</code></pre>\n<p>这个树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个 blob 对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>\n<h2>历史记录</h2>\n<p>Git的历史记录是基于快照构建的，相当于一组按时间排列的照片。每一次提交都是一张照片，包含了项目的完整状态，包括所有文件及其内容。通过查看历史记录，可以了解项目的演变过程，以及每个版本的具体修改内容。</p>\n<hr>\n<p><strong>在git的专业术语中</strong>: 提交被称为commit，它包含一个唯一的标识符（commit hash），以及一个指向父提交（parent commit）的指针。历__史记录是由快照组成的有向无环图。</p>\n<p>在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>\n<pre><code class=\"language-bash\">o &lt;-- o &lt;-- o &lt;-- o\n            ^\n             \\\n              --- o &lt;-- o\n</code></pre>\n<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>\n<pre><code class=\"language-bash\">o &lt;-- o &lt;-- o &lt;-- o &lt;----  o \n            ^            /\n             \\          v\n              --- o &lt;-- o\n</code></pre>\n<p>注：Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。</p>\n<h2>数据模型及其伪代码表示</h2>\n<p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>\n<pre><code class=\"language-python\">// 文件就是一组数据\ntype blob = array&lt;byte&gt;\n\n// 一个包含文件和目录的目录\ntype tree = map&lt;string, tree | blob&gt;\n\n// 每个提交都包含一个父辈，元数据和顶层树\ntype commit = struct {\n    parents: array&lt;commit&gt;\n    author: string\n    message: string\n    snapshot: tree\n}\n</code></pre>\n<p>这是一种简洁的历史模型。</p>\n<p>Git 中的对象可以是 blob、树或提交：</p>\n<pre><code>type object = blob | tree | commit\n</code></pre>\n<p>Git 在储存数据时，所有的对象都会基于它们的 <a href=\"https://en.wikipedia.org/wiki/SHA-1\">SHA-1 哈希</a> 进行寻址。</p>\n<pre><code>objects = map&lt;string, object&gt;\n\ndef store(object):\n    id = sha1(object)\n    objects[id] = object\n\ndef load(id):\n    return objects[id]\n</code></pre>\n<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>\n<p>例如，<a href=\"#snapshots\">上面</a> 例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p>\n<pre><code>100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt\n040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo\n</code></pre>\n<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob) 和 <code>foo</code>\n(树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p>\n<pre><code>git is wonderful\n</code></pre>\n<h2>引用</h2>\n<p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p>\n<p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p>\n<pre><code>references = map&lt;string, string&gt;\n\ndef update_reference(name, id):\n    references[name] = id\n\ndef read_reference(name):\n    return references[name]\n\ndef load_reference(name_or_id):\n    if name_or_id in references:\n        return load(references[name_or_id])\n    else:\n        return load(name_or_id)\n</code></pre>\n<p>这样，Git 就可以使用诸如 &quot;master&quot; 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>\n<p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 &quot;HEAD&quot;。</p>\n<h2>仓库</h2>\n<p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</p>\n<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>\n<p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p>\n<h2>暂存区</h2>\n<p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>\n<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p>\n<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>\n<h2>Git 安装与使用</h2>\n<h3>安装</h3>\n<h4>命令行版本</h4>\n<ul>\n<li><p>Windows:</p>\n<ul>\n<li>直接下载安装文件\n<a href=\"https://git-scm.com/download/win\">Git for Windows</a></li>\n<li>Winget 安装 <code>winget install git.git</code></li>\n<li>Chocolatey 安装 <code>choco install git</code></li>\n<li>scoop 安装 <code>scoop install git</code></li>\n</ul>\n</li>\n<li><p>linux:</p>\n<ul>\n<li>Debian/Ubuntu: <code>sudo apt-get install git</code></li>\n<li>Fedora/CentOS/RHEL: <code>sudo yum install git</code> or <code>sudo dnf install git</code></li>\n<li>Arch Linux: <code>sudo pacman -S git</code></li>\n<li>openSUSE: <code>sudo zypper install git</code></li>\n</ul>\n</li>\n<li><p>macOS: <code>brew install git</code></p>\n</li>\n</ul>\n<p>安装后检测是否安装成功：<code>git --version</code>\n<img src=\"./img/git/image_1.png\" alt=\"alt text\"></p>\n<h4>GUI版本</h4>\n<ul>\n<li><a href=\"https://desktop.github.com/\">GitHub Desktop</a></li>\n<li><a href=\"https://www.gitkraken.com/\">GitKraken</a></li>\n</ul>\n<blockquote>\n<p>当然我依然推荐先使用好命令行版本，再使用 GUI版本。一些代码编辑器和IDE都内置了一些Git插件也可以免去命令行的使用，但是只有首先理解了Git的基本概念和命令，才能更好地使用这些工具。</p>\n</blockquote>\n<h3>Git 初始配置</h3>\n<ul>\n<li><code>git config --global user.name &quot;your name&quot;</code>: 设置用户名</li>\n<li><code>git config --global user.email &quot;your email&quot;</code>: 设置用户邮箱</li>\n<li>添加Github SSH key到SSH agent: <code>ssh-keygen -t ed25519 -C &quot;your email&quot;</code> 然后复制生成的公钥到Github的SSH key中。（可选）</li>\n</ul>\n<pre><code class=\"language-1.\">2. 在边栏的“Access”部分中，单击 “SSH and GPG keys”\n3. 单击“新建 SSH 密钥”或“添加 SSH 密钥” 。\n4. 在 &quot;Title&quot;（标题）字段中，为新密钥添加描述性标签。 例如，如果使用的是个人笔记本电脑，则可以将此密钥称为“个人笔记本电脑”。\n5. 在“密钥”字段中，粘贴公钥。\n6. 单击“添加 SSH 密钥”。\n</code></pre>\n<p><img src=\"/image/Git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/1760152030554.png\" alt=\"1760152030554\"></p>\n<h3>Git 命令</h3>\n<ul>\n<li><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li>\n<li><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</li>\n<li><code>git status</code>: 显示当前的仓库状态</li>\n<li><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li>\n<li><code>git commit</code>: 创建一个新的提交<ul>\n<li>如何编写 <a href=\"https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html\">良好的提交信息</a>!</li>\n<li>为何要 <a href=\"https://chris.beams.io/posts/git-commit/\">编写良好的提交信息</a></li>\n</ul>\n</li>\n<li><code>git log</code>: 显示历史日志</li>\n<li><code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li>\n<li><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li>\n<li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li>\n<li><code>git checkout &lt;revision&gt;</code>: 更新 HEAD（如果是检出分支则同时更新当前分支）</li>\n</ul>\n<h2>分支和合并</h2>\n<ul>\n<li><code>git branch</code>: 显示分支</li>\n<li><code>git branch &lt;name&gt;</code>: 创建分支</li>\n<li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支<ul>\n<li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li>\n</ul>\n</li>\n<li><code>git merge &lt;revision&gt;</code>: 合并到当前分支</li>\n<li><code>git mergetool</code>: 使用工具来处理合并冲突</li>\n<li><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li>\n</ul>\n<h2>远端操作</h2>\n<ul>\n<li><p><code>git remote</code>: 列出远端</p>\n</li>\n<li><p><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</p>\n</li>\n<li><p><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</p>\n</li>\n<li><p><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</p>\n</li>\n<li><p><code>git fetch</code>: 从远端获取对象/索引</p>\n</li>\n<li><p><code>git pull</code>: 相当于 <code>git fetch; git merge</code></p>\n</li>\n<li><p><code>git clone</code>: 从远端下载仓库 (这是下载代码的主要方式也是最常用的命令之一)\n<img src=\"/image/Git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/1760152289709.png\" alt=\"1760152289709\">\n复制这个链接使用<code>git clone https://github.com/Jdhggg/hello-algo.git</code> 即可下载仓库文件到当前目录</p>\n<p>当然也可以下载到指定目录下，例如<code>git clone https://github.com/Jdhggg/hello-algo.git ~/Documents/hello-algo</code></p>\n</li>\n</ul>\n<h2>撤销</h2>\n<ul>\n<li><code>git commit --amend</code>: 编辑提交的内容或信息</li>\n<li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li>\n<li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li>\n<li><code>git restore</code>: git2.32 版本后取代 git reset 进行许多撤销操作</li>\n</ul>\n<h1>Git 高级操作</h1>\n<ul>\n<li><code>git config</code>: Git 是一个 <a href=\"https://git-scm.com/docs/git-config\">高度可定制的</a> 工具</li>\n<li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li>\n<li><code>git add -p</code>: 交互式暂存</li>\n<li><code>git rebase -i</code>: 交互式变基</li>\n<li><code>git blame</code>: 查看最后修改某行的人</li>\n<li><code>git stash</code>: 暂时移除工作目录下的修改内容</li>\n<li><code>git bisect</code>: 通过二分查找搜索历史记录</li>\n<li><code>.gitignore</code>: <a href=\"https://git-scm.com/docs/gitignore\">指定</a> 故意不追踪的文件</li>\n</ul>\n",
      "featured_image": "/image/git.png"
    },
    {
      "slug": "Shell_tool",
      "title": "Shell 脚本",
      "date": "2025-10-07T11:02:53.000Z",
      "tags": [
        "计算机基础"
      ],
      "excerpt": " Shell 脚本\r\n\r\n到目前为止，我们已经学习了如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。\r\n\r\n\r\nshell 脚本的复杂性进一步提高。\r\n\r\n\r\n大多数 shell 都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell 脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事...",
      "content": "<h1>Shell 脚本</h1>\n<p>到目前为止，我们已经学习了如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>\n<p>shell 脚本的复杂性进一步提高。</p>\n<p>大多数 shell 都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell 脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p>\n<p>在 bash 中为变量赋值的语法是 <code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。\n需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序 <code>foo</code> 并将 <code>=</code> 和 <code>bar</code> 作为参数。\n总的来说，在 shell 脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>\n<p>Bash 中的字符串通过 <code>&#39;</code> 和 <code>&quot;</code> 分隔符来定义，但是它们的含义并不相同。以 <code>&#39;</code> 定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code> 定义的字符串会将变量值进行替换。</p>\n<pre><code class=\"language-bash\">foo=bar\necho &quot;$foo&quot;\n# 打印 bar\necho &#39;$foo&#39;\n# 打印 $foo\n</code></pre>\n<p>和其他大多数的编程语言一样，<code>bash</code> 也支持 <code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地，\n <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用 <code>cd</code> 进入该文件夹。</p>\n<pre><code class=\"language-bash\">mcd () {\n    mkdir -p &quot;$1&quot;\n    cd &quot;$1&quot;\n}\n</code></pre>\n<p>这里 <code>$1</code> 是脚本的第一个参数。与其他脚本语言不同的是，bash 使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举了其中一些变量，更完整的列表可以参考 <a href=\"https://www.tldp.org/LDP/abs/html/special-chars.html\">这里</a>。</p>\n<ul>\n<li><code>$0</code> - 脚本名</li>\n<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>\n<li><code>$@</code> - 所有参数</li>\n<li><code>$#</code> - 参数个数</li>\n<li><code>$?</code> - 前一个命令的返回值</li>\n<li><code>$$</code> - 当前脚本的进程识别码</li>\n<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code> 再尝试一次。</li>\n<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>\n</ul>\n<p>命令通常使用 <code>STDOUT</code> 来返回输出值，使用 <code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。\n返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值 0 表示正常执行，其他所有非 0 的返回值都表示有错误发生。</p>\n<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于 <a href=\"https://en.wikipedia.org/wiki/Short-circuit_evaluation\">短路运算符</a>（short-circuiting） 同一行的多个命令可以用 <code>;</code> 分隔。程序 <code>true</code> 的返回码永远是 <code>0</code>，<code>false</code> 的返回码永远是 <code>1</code>。让我们看几个例子</p>\n<pre><code class=\"language-bash\">false || echo &quot;Oops, fail&quot;\n# Oops, fail\n\ntrue || echo &quot;Will not be printed&quot;\n#\n\ntrue &amp;&amp; echo &quot;Things went well&quot;\n# Things went well\n\nfalse &amp;&amp; echo &quot;Will not be printed&quot;\n#\n\nfalse ; echo &quot;This will always run&quot;\n# This will always run\n</code></pre>\n<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p>\n<p>当您通过 <code>$( CMD )</code> 这样的方式来执行 <code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN 传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>\n<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n\necho &quot;Starting program at $(date)&quot; # date会被替换成日期和时间\n\necho &quot;Running program $0 with $# arguments with pid $$&quot;\n\nfor file in &quot;$@&quot;; do\n    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null\n    # 如果模式没有找到，则grep退出状态为 1\n    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息\n    if [[ $? -ne 0 ]]; then\n        echo &quot;File $file does not have any foobar, adding one&quot;\n        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;\n    fi\ndone\n</code></pre>\n<p>在条件语句中，我们比较 <code>$?</code> 是否等于 0。\nBash 实现了许多类似的比较操作，您可以查看 <a href=\"https://man7.org/linux/man-pages/man1/test.1.html\"><code>test 手册</code></a>。\n在 bash 中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见 <a href=\"http://mywiki.wooledge.org/BashFAQ/031\">这里</a>。</p>\n<p>当执行脚本时，我们经常需要提供形式类似的参数。bash 使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为 shell 的 <em>通配</em>（<em>globbing</em>）</p>\n<ul>\n<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件 <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code> 这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而 <code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。</li>\n<li>花括号 <code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>\n</ul>\n<pre><code class=\"language-bash\">convert image.{png,jpg}\n# 会展开为\nconvert image.png image.jpg\n\ncp /path/to/project/{foo,bar,baz}.sh /newpath\n# 会展开为\ncp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath\n\n# 也可以结合通配使用\nmv *{.py,.sh} folder\n# 会移动所有 *.py 和 *.sh 文件\n\nmkdir foo bar\n\n# 下面命令会创建 foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h 这些文件\ntouch {foo,bar}/{a..h}\ntouch foo/x bar/y\n# 比较文件夹 foo 和 bar 中包含文件的不同\ndiff &lt;(ls foo) &lt;(ls bar)\n# 输出\n# &lt; x\n# ---\n# &gt; y\n</code></pre>\n<!-- Lastly, pipes `|` are a core feature of scripting. Pipes connect one program's output to the next program's input. We will cover them more in detail in the data wrangling lecture. -->\n\n<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href=\"https://github.com/koalaman/shellcheck\">shellcheck</a> 这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p>\n<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>\n<pre><code class=\"language-python\">#!/usr/local/bin/python\nimport sys\nfor arg in reversed(sys.argv[1:]):\n    print(arg)\n</code></pre>\n<p>内核知道去用 python 解释器而不是 shell 命令来运行这段脚本，是因为脚本的开头第一行的 <a href=\"https://en.wikipedia.org/wiki/Shebang_(Unix)\">shebang</a>。</p>\n<p>在 <code>shebang</code> 行中使用 <a href=\"https://man7.org/linux/man-pages/man1/env.1.html\"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的 <code>PATH</code> 环境变量来进行定位。\n例如，使用了 <code>env</code> 的 shebang 看上去是这样的 <code>#!/usr/bin/env python</code>。</p>\n<p>shell 函数和脚本有如下一些不同点：</p>\n<ul>\n<li>函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>\n<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>\n<li>函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。使用 <a href=\"https://man7.org/linux/man-pages/man1/export.1p.html\"><code>export</code></a> 导出的环境变量会以传值的方式传递给脚本。</li>\n<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。</li>\n</ul>\n<h1>Shell 工具</h1>\n<h2>查看命令如何使用</h2>\n<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？\n一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>\n<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加 <code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用 <code>man</code> 命令。<a href=\"https://man7.org/linux/man-pages/man1/man.1.html\"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>\n<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的 <code>-i</code>。\n事实上，目前我们给出的所有命令的说明链接，都是网页版的 Linux 命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>\n<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。\n<a href=\"https://tldr.inbrowser.app/\">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>\n<p>例如，在 tldr 上搜索 <a href=\"https://tldr.inbrowser.app/pages/common/tar\"><code>tar</code></a> 的用法。</p>\n<h2>查找文件</h2>\n<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类 UNIX 系统都包含一个名为 <a href=\"https://www.runoob.com/linux/linux-comm-find.html\"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code> 命令会递归地搜索符合条件的文件，例如：</p>\n<pre><code class=\"language-bash\"># 查找所有名称为src的文件夹\nfind . -name src -type d\n# 查找所有文件夹路径中包含test的python文件\nfind . -path &#39;*/test/*.py&#39; -type f\n# 查找前一天修改的所有文件\nfind . -mtime -1\n# 查找所有大小在500k至10M的tar.gz文件\nfind . -size +500k -size -10M -name &#39;*.tar.gz&#39;\n</code></pre>\n<p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>\n<pre><code class=\"language-bash\"># 删除全部扩展名为.tmp 的文件\nfind . -name &#39;*.tmp&#39; -exec rm {} \\;\n# 查找全部的 PNG 文件并将其转换为 JPG\nfind . -name &#39;*.png&#39; -exec magick {} {}.jpg \\;\n</code></pre>\n<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name &#39;*PATTERN*&#39;</code> (如果您希望模式匹配时是不区分大小写，可以使用 <code>-iname</code> 选项）</p>\n<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。\n记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>\n<p>例如，<a href=\"https://github.com/sharkdp/fd\"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为 <code>find</code> 的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持 unicode 并且我认为它的语法更符合直觉。以模式 <code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>\n<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>\n<p>这就要靠 <a href=\"https://www.runoob.com/linux/linux-comm-locate.html\"><code>locate</code></a> 了。\n<code>locate</code> 使用一个由 <a href=\"https://www.runoob.com/linux/linux-comm-updatedb.html\"><code>updatedb</code></a> 负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href=\"https://www.runoob.com/linux/linux-comm-crontab.html\"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code> 则只能通过文件名。。</p>\n<h2>查找代码</h2>\n<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>\n<p>为了实现这一点，很多类 UNIX 的系统都提供了 <a href=\"https://www.runoob.com/linux/linux-comm-grep.html\"><code>grep</code></a> 命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的 shell 工具，我们会在后续的数据清理课程中深入的探讨它。</p>\n<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>\n<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略 <code>.git</code> 文件夹，使用多 CPU 等等。</p>\n<p>因此也出现了很多它的替代品，包括 <a href=\"https://beyondgrep.com/\">ack</a>, <a href=\"https://github.com/ggreer/the_silver_searcher\">ag</a> 和 <a href=\"https://github.com/BurntSushi/ripgrep\">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>\n<pre><code class=\"language-bash\"># 查找所有使用了 requests 库的文件\nrg -t py &#39;import requests&#39;\n# 查找所有没有写 shebang 的文件（包含隐藏文件）\nrg -u --files-without-match &quot;^#\\!&quot;\n# 查找所有的foo字符串，并打印其之后的5行\nrg foo -A 5\n# 打印匹配的统计信息（匹配的行和文件的数量）\nrg --stats PATTERN\n</code></pre>\n<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>\n<h2>查找 shell 命令</h2>\n<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用 shell 的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>\n<p><code>history</code> 命令允许您以程序员的方式来访问 shell 中输入的历史命令。这个命令会在标准输出中打印 shell 中的历史命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。\n<code>history | grep find</code> 会打印包含 find 子串的命令。</p>\n<p>对于大多数的 shell 来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>\n<p>反复按下就会在所有搜索结果中循环。在 <a href=\"https://github.com/zsh-users/zsh-history-substring-search\">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>\n<p><code>Ctrl+R</code> 可以配合 <a href=\"https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r\">fzf</a> 使用。<code>fzf</code> 是一个通用的模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>\n<p>另外一个和历史命令相关的技巧我喜欢称之为 <strong>基于历史的自动补全</strong>。\n这一特性最初是由 <a href=\"https://fishshell.com/\">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前的 shell 命令进行补全。这一功能在 <a href=\"https://github.com/zsh-users/zsh-autosuggestions\">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>\n<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。\n为此你需要在 <code>.bashrc</code> 中添加 <code>HISTCONTROL=ignorespace</code> 或者向 <code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。\n如果你不小心忘了在前面加空格，可以通过编辑 <code>.bash_history</code> 或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>\n<h2>文件夹导航</h2>\n<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href=\"https://www.runoob.com/linux/linux-comm-alias.html\">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>\n<p>由于本教程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href=\"https://github.com/clvv/fasd\"><code>fasd</code></a> 和 <a href=\"https://github.com/wting/autojump\">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>\n<p>Fasd 基于 <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm\"><em>frecency</em> </a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用 <code>j cool</code> 代替即可。</p>\n<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href=\"https://linux.die.net/man/1/tree\"><code>tree</code></a>, <a href=\"https://github.com/Canop/broot\"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href=\"https://github.com/jarun/nnn\"><code>nnn</code></a> 或 <a href=\"https://github.com/ranger/ranger\"><code>ranger</code></a>。</p>\n"
    },
    {
      "slug": "Shell",
      "title": "Shell 是什么？",
      "date": "2025-10-06T11:02:53.000Z",
      "tags": [
        "计算机基础"
      ],
      "excerpt": "\r\n The Shell\r\n> 这是一篇面向新加入实验室的同学撰写的计算机常用工具入门教程之Shell\r\n\r\n  Shell 是什么？\r\n\r\n如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。\r\n这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或...",
      "content": "<h1>The Shell</h1>\n<blockquote>\n<p>这是一篇面向新加入实验室的同学撰写的计算机常用工具入门教程之Shell</p>\n</blockquote>\n<h2>Shell 是什么？</h2>\n<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。\n这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。\n为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>\n<p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>\n<p>本节课我们会使用 Bourne Again SHell, 简称 &quot;bash&quot; 。\n这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开 shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>\n<ul>\n<li><p>如果你使用的是<code>windows</code> ，可以使用 <code>cmd</code> 启动一个终端,但还本文使用的命令属于<code>Unix</code>风格，<code>cmd</code>可能无法执行某些命令。\n所以建议在Windows 中建议使用 <code>WSl</code> 或者 <code>pwsh</code> 来跟进课程。</p>\n<ul>\n<li><a href=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">wsl</a> 是 Windows 10 的一个功能，允许您使用 Linux 的命令行界面，本质上是一个虚拟机，但是这一直接调用部分硬件，如 CPU、内存、硬盘、显卡等等，使用 WSL 来做一些开发任务也十分方便。</li>\n<li><a href=\"https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.5\">pwsh</a> 是 PowerShell 的一个实现，PowerShell 是一个开源的跨平台 shell。因为<code>pwsh</code>是跨平台的，所以在 Windows 和 Linux 中都是可用的，，它允许您使用 .NET 框架，因此您可以使用 C# 或 PowerShell 来编写脚本，并且对于一些<code>bash</code>命令可以直接映射执行。</li>\n</ul>\n</li>\n<li><p>对于<code>MacOS</code> 中，可以使用 <code>terminal</code>,应为<code>MacOS</code> 是一个 Unix 系统，所以它也支持本课程的大多数 shell 命令。</p>\n</li>\n<li><p>对于<code>Linux</code> 中，可以使用 <code>bash</code> 启动一个终端，本课程使用的就是<code>linux</code>系统。</p>\n</li>\n</ul>\n<h2>使用 shell</h2>\n<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>\n<pre><code class=\"language-console\">missing:~$ \n</code></pre>\n<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（&quot;current working directory&quot;）或者说您当前所在的位置是 <code>~</code> (表示 &quot;home&quot;)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入 <em>命令</em> ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p>\n<pre><code class=\"language-console\">missing:~$ date\nFri 10 Jan 2020 11:49:31 AM EST\nmissing:~$ \n</code></pre>\n<p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em> ：</p>\n<pre><code class=\"language-console\">missing:~$ echo hello\nhello\n</code></pre>\n<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。\nshell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\\</code> 进行处理（<code>My\\ Photos</code>）。</p>\n<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em>  <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p>\n<pre><code class=\"language-console\">missing:~$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nmissing:~$ which echo\n/bin/echo\nmissing:~$ /bin/echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n</code></pre>\n<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用\n<code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p>\n<h2>在 shell 中导航</h2>\n<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在 Windows 上是 <code>\\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在 Windows 上每个盘都有一个根目录（例如：\n<code>C:\\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>\n<pre><code class=\"language-console\">missing:~$ pwd\n/home/missing\nmissing:~$ cd /home\nmissing:/home$ pwd\n/home\nmissing:/home$ cd ..\nmissing:/$ pwd\n/\nmissing:/$ cd ./home\nmissing:/home$ pwd\n/home\nmissing:/home$ cd missing\nmissing:~$ pwd\n/home/missing\nmissing:~$ ../../bin/echo hello\nhello\n</code></pre>\n<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>\n<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>\n<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>\n<pre><code class=\"language-console\">missing:~$ ls\nmissing:~$ cd ..\nmissing:/home$ ls\nmissing\nmissing:/home$ cd ..\nmissing:/$ ls\nbin\nboot\ndev\netc\nhome\n...\n</code></pre>\n<p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p>\n<pre><code>  -l                         use a long listing format\n</code></pre>\n<pre><code class=\"language-console\">missing:~$ ls -l /home\ndrwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing\n</code></pre>\n<p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示\n<code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。\n（<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p>\n<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>\n<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p>\n<pre><code class=\"language-console\">missing:~$ man ls\n</code></pre>\n<p>这时候你的屏幕差不多已经满了，你可使用<code>clear</code>或 <code>Ctrl+L</code> 来清屏</p>\n<h2>在程序间创建连接</h2>\n<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。\n当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。\n通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。\n但是，我们也可以重定向这些流！</p>\n<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>\n<pre><code class=\"language-console\">missing:~$ echo hello &gt; hello.txt\nmissing:~$ cat hello.txt\nhello\nmissing:~$ cat &lt; hello.txt\nhello\nmissing:~$ cat &lt; hello.txt &gt; hello2.txt\nmissing:~$ cat hello2.txt\nhello\n</code></pre>\n<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。\n<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来： </p>\n<pre><code class=\"language-console\">missing:~$ ls -l / | tail -n1\ndrwxr-xr-x 1 root  root  4096 Jun 20  2019 var\nmissing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#39; &#39; -f2\n219\n</code></pre>\n<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>\n<h2>一个功能全面又强大的工具</h2>\n<p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。\n您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。\n通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。\n取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。\n当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>\n<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。\n因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p>\n<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p>\n<pre><code>/sys/class/backlight\n</code></pre>\n<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>\n<pre><code class=\"language-console\">$ sudo find -L /sys/class/backlight -maxdepth 2 -name &#39;*brightness*&#39;\n/sys/class/backlight/thinkpad_screen/brightness\n$ cd /sys/class/backlight/thinkpad_screen\n$ sudo echo 3 &gt; brightness\nAn error occurred while redirecting file &#39;brightness&#39;\nopen: Permission denied\n</code></pre>\n<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了\n<code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。\n<code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。\n回到上面更改屏幕亮度命令执行的报错，为了能让 <code>sudo echo</code> 命令输出的亮度值写入 brightness 文件， <em>shell</em> (权限为当前用户) 会先尝试打开 brightness 文件，但此时操作 shell 的不是根（root）用户，所以系统拒绝了这个打开操作，提示无权限。</p>\n<p>明白这一点后，我们可以这样操作：</p>\n<pre><code class=\"language-console\">$ echo 3 | sudo tee brightness\n</code></pre>\n<p>此时打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。\n这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种 LED 的状态（路径可能会有所不同）：</p>\n<pre><code class=\"language-console\">$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness\n</code></pre>\n"
    },
    {
      "slug": "command-line",
      "title": "命令行环境",
      "date": "2025-10-05T11:02:53.000Z",
      "tags": [
        "计算机基础"
      ],
      "excerpt": " 命令行环境\n\n当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。\n\n我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。\n\n我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是...",
      "content": "<h1>命令行环境</h1>\n<p>当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p>\n<p>我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p>\n<p>我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p>\n<h1>任务控制</h1>\n<p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用 <code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用 <code>Ctrl-C</code> 来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p>\n<h2>结束进程</h2>\n<p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种 <em>软件中断</em>。</p>\n<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个 <code>SIGINT</code> 信号到进程。</p>\n<p>下面这个 Python 程序向您展示了捕获信号 <code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用 <code>SIGQUIT</code> 信号，通过输入 <code>Ctrl-\\</code> 可以发送该信号。</p>\n<pre><code class=\"language-python\">#!/usr/bin/env python\nimport signal, time\n\ndef handler(signum, time):\n    print(&quot;\\nI got a SIGINT, but I am not stopping&quot;)\n\nsignal.signal(signal.SIGINT, handler)\ni = 0\nwhile True:\n    time.sleep(.1)\n    print(&quot;\\r{}&quot;.format(i), end=&quot;&quot;)\n    i += 1\n</code></pre>\n<p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次 <code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code> 是我们在终端输入 <code>Ctrl</code> 时的表示形式：</p>\n<pre><code>$ python sigint.py\n24^C\nI got a SIGINT, but I am not stopping\n26^C\nI got a SIGINT, but I am not stopping\n30^\\[1]    39913 quit       python sigint.pyƒ\n</code></pre>\n<p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href=\"https://www.runoob.com/linux/linux-comm-kill.html\"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p>\n<h2>暂停和后台执行进程</h2>\n<p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code> 是 Terminal Stop 的缩写（即 <code>terminal</code> 版本的 SIGSTOP）。</p>\n<p>我们可以使用 <a href=\"https://www.runoob.com/linux/linux-comm-fg.html\"><code>fg</code></a> 或 <a href=\"https://www.runoob.com/linux/linux-comm-bg.html\"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>\n<p><a href=\"https://www.runoob.com/linux/linux-comm-jobs.html\"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href=\"https://www.runoob.com/linux/linux-comm-pgrep.html\"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>\n<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>\n<p>让已经在运行的进程转到后台运行，您可以键入 <code>Ctrl-Z</code> ，然后紧接着再输入 <code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号 <code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href=\"https://www.runoob.com/linux/linux-comm-nohup.html\"><code>nohup</code></a>（一个用来忽略 <code>SIGHUP</code> 的封装）来运行程序。针对已经运行的程序，可以使用 <code>disown</code> 。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p>\n<p>下面这个简单的会话中展示来了些概念的应用。</p>\n<pre><code>$ sleep 1000\n^Z\n[1]  + 18653 suspended  sleep 1000\n\n$ nohup sleep 2000 &amp;\n[2] 18745\nappending output to nohup.out\n\n$ jobs\n[1]  + suspended  sleep 1000\n[2]  - running    nohup sleep 2000\n\n$ bg %1\n[1]  - 18653 continued  sleep 1000\n\n$ jobs\n[1]  - running    sleep 1000\n[2]  + running    nohup sleep 2000\n\n$ kill -STOP %1\n[1]  + 18653 suspended (signal)  sleep 1000\n\n$ jobs\n[1]  + suspended (signal)  sleep 1000\n[2]  - running    nohup sleep 2000\n\n$ kill -SIGHUP %1\n[1]  + 18653 hangup     sleep 1000\n\n$ jobs\n[2]  + running    nohup sleep 2000\n\n$ kill -SIGHUP %2\n\n$ jobs\n[2]  + running    nohup sleep 2000\n\n$ kill %2\n[2]  + 18745 terminated  nohup sleep 2000\n\n$ jobs\n</code></pre>\n<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>\n<p>您可以在 <a href=\"https://www.kyleblog.cn/posts/signal\">这里</a> 或使用 <code>kill -l</code> 来获取更多关于信号的信息。</p>\n<h1>终端多路复用</h1>\n<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>\n<p>像 <a href=\"https://www.runoob.com/linux/linux-comm-tmux.html\"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>\n<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>\n<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>\n<p>现在最流行的终端多路器是 <a href=\"https://www.runoob.com/linux/linux-comm-tmux.html\"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>\n<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下 <code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>\n<ul>\n<li><p><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口</p>\n<ul>\n<li><code>tmux</code> 开始一个新的会话</li>\n<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>\n<li><code>tmux ls</code> 列出当前所有会话</li>\n<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>\n<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>\n</ul>\n</li>\n<li><p><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分</p>\n<ul>\n<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code> 关闭</li>\n<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>\n<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>\n<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>\n<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>\n<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>\n</ul>\n</li>\n<li><p><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell</p>\n<ul>\n<li><code>&lt;C-b&gt; &quot;</code> 水平分割</li>\n<li><code>&lt;C-b&gt; %</code> 垂直分割</li>\n<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li>\n<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>\n<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>\n<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>\n</ul>\n</li>\n</ul>\n<h1>别名</h1>\n<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>\n<pre><code class=\"language-bash\">alias alias_name=&quot;command_to_alias arg1 arg2&quot;\n</code></pre>\n<p>注意， <code>=</code> 两边是没有空格的，因为 <a href=\"https://www.runoob.com/linux/linux-comm-alias.html\"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>\n<p>别名有许多很方便的特性:</p>\n<pre><code class=\"language-bash\"># 创建常用命令的缩写\nalias ll=&quot;ls -lh&quot;\n\n# 能够少输入很多\nalias gs=&quot;git status&quot;\nalias gc=&quot;git commit&quot;\nalias v=&quot;vim&quot;\n\n# 手误打错命令也没关系\nalias sl=ls\n\n# 重新定义一些命令行的默认行为\nalias mv=&quot;mv -i&quot;           # -i prompts before overwrite\nalias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed\nalias df=&quot;df -h&quot;           # -h prints human readable format\n\n# 别名可以组合使用\nalias la=&quot;ls -A&quot;\nalias lla=&quot;la -l&quot;\n\n# 在忽略某个别名\n\\ls\n# 或者禁用别名\nunalias la\n\n# 获取别名的定义\nalias ll\n# 会打印 ll=&#39;ls -lh&#39;\n</code></pre>\n<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是 <code>.bashrc</code> 或 <code>.zshrc</code>，下一节我们就会讲到。</p>\n<h1>配置文件（Dotfiles）</h1>\n<p>很多程序的配置都是通过纯文本格式的被称作 <em>点文件</em> 的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code> 并不会显示它们）。</p>\n<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href=\"https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html\">这里</a> 有非常好的资源</p>\n<p>对于 <code>bash</code> 来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>\n<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>\n<p>还有一些其他的工具也可以通过 <em>点文件</em> 进行配置：</p>\n<ul>\n<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>\n<li><code>git</code> - <code>~/.gitconfig</code></li>\n<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>\n<li><code>ssh</code> - <code>~/.ssh/config</code></li>\n<li><code>tmux</code> - <code>~/.tmux.conf</code></li>\n</ul>\n<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>\n<ul>\n<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>\n<li><strong>可移植性</strong>: 您的工具在任何地方都以相同的配置工作</li>\n<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>\n<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>\n</ul>\n<p>配置文件中需要放些什么？您可以通过在线文档和帮助手册了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的 <a href=\"https://github.com/search?o=desc&q=dotfiles&s=stars&type=Repositories\">dotfiles 仓库</a>。</p>\n<h2>可移植性</h2>\n<p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p>\n<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>\n<pre><code class=\"language-bash\">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi\n\n# 使用和 shell 相关的配置时先检查当前 shell 类型\nif [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi\n\n# 您也可以针对特定的设备进行配置\nif [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi\n</code></pre>\n<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>\n<pre><code>[include]\n    path = ~/.gitconfig_local\n</code></pre>\n<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>\n<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>\n<pre><code class=\"language-bash\"># Test if ~/.aliases exists and source it\nif [ -f ~/.aliases ]; then\n    source ~/.aliases\nfi\n</code></pre>\n<h1>远端设备</h1>\n<p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p>\n<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>\n<pre><code class=\"language-bash\">ssh foo@bar.mit.edu\n</code></pre>\n<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如 <code>bar.mit.edu</code>），也可以使用 IP 指定（例如 <code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>\n<h2>执行命令</h2>\n<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。\n<code>ssh foobar@server ls</code> 可以直接在用 foobar 的命令下执行 <code>ls</code> 命令。\n想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>\n<h2>SSH 密钥</h2>\n<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>\n<h3>密钥生成</h3>\n<p>使用 <a href=\"https://www.runoob.com/python3/linux-comm-ssh.html\"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>\n<pre><code class=\"language-bash\">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519\n</code></pre>\n<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <code>ssh-agent</code>或 <code>gpg-agent</code>，这样就不需要每次都输入该密码了。</p>\n<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub(这部分在Git教程中有介绍)，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>\n<h3>基于密钥的认证机制</h3>\n<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>\n<pre><code class=\"language-bash\">cat .ssh/id_ed25519.pub | ssh foobar@remote &#39;cat &gt;&gt; ~/.ssh/authorized_keys&#39;\n</code></pre>\n<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>\n<pre><code class=\"language-bash\">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote\n</code></pre>\n<h2>通过 SSH 复制文件</h2>\n<p>使用 ssh 复制文件有很多方法：</p>\n<ul>\n<li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现 <code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href=\"https://www.runoob.com/linux/linux-comm-tee.html\"><code>tee</code></a> 命令会将标准输出写入到一个文件；</li>\n<li><a href=\"https://www.runoob.com/linux/linux-comm-scp.html\"><code>scp</code></a> ：当需要拷贝大量的文件或目录时，使用 <code>scp</code> 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li>\n<li><a href=\"https://www.runoob.com/linux/linux-comm-rsync.html\"><code>rsync</code></a> 对 <code>scp</code> 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code> 标记实现断点续传。<code>rsync</code> 的语法和 <code>scp</code> 类似；</li>\n</ul>\n<h2>端口转发</h2>\n<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>\n<p>此时就需要进行 <em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图）。</p>\n<p><strong>本地端口转发</strong>\n<img src=\"/image/a28N8.png\" alt=\"Local Port Forwarding\"></p>\n<p><strong>远程端口转发</strong>\n<img src=\"/image/4iK3b.png\" alt=\"Remote Port Forwarding\"></p>\n<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>\n<h2>SSH 配置</h2>\n<p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p>\n<pre><code class=\"language-bash\">alias my_server=&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server&quot;\n</code></pre>\n<p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p>\n<pre><code class=\"language-bash\">Host vm\n    User foobar\n    HostName 172.16.174.141\n    Port 2222\n    IdentityFile ~/.ssh/id_ed25519\n    LocalForward 9999 localhost:8888\n\n# 在配置文件中也可以使用通配符\nHost *.mit.edu\n    User foobaz\n</code></pre>\n<p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似 <code>scp</code>、<code>rsync</code> 和 <code>mosh</code> 的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p>\n<p>注意，<code>~/.ssh/config</code> 文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p>\n<p>服务器侧的配置通常放在 <code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p>\n<h2>杂项</h2>\n<p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href=\"https://mosh.org/\">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p>\n<p>有时将一个远端文件夹挂载到本地会比较方便， <a href=\"https://github.com/libfuse/sshfs\">sshfs</a> 可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p>\n<h1>Shell &amp; 框架</h1>\n<p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code> shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。</p>\n<p>例如，<code>zsh</code> shell 是 <code>bash</code> 的超集并提供了一些方便的功能：</p>\n<ul>\n<li>智能替换, <code>**</code></li>\n<li>行内替换/通配符扩展</li>\n<li>拼写纠错</li>\n<li>更好的 tab 补全和选择</li>\n<li>路径展开 (<code>cd /u/lo/b</code> 会被展开为 <code>/usr/local/bin</code>)</li>\n</ul>\n<p><strong>框架</strong> 也可以改进您的 shell。比较流行的通用框架包括 <a href=\"https://github.com/sorin-ionescu/prezto\">prezto</a> 或 <a href=\"https://ohmyz.sh/\">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如 <a href=\"https://github.com/zsh-users/zsh-syntax-highlighting\">zsh 语法高亮</a> 或 <a href=\"https://github.com/zsh-users/zsh-history-substring-search\">zsh 历史子串查询</a>。 像 <a href=\"https://fishshell.com/\">fish</a> 这样的 shell 包含了很多用户友好的功能，其中一些特性包括：</p>\n<ul>\n<li>向右对齐</li>\n<li>命令语法高亮</li>\n<li>历史子串查询</li>\n<li>基于手册页面的选项补全</li>\n<li>更智能的自动补全</li>\n<li>提示符主题</li>\n</ul>\n<p>需要注意的是，使用这些框架可能会降低您 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡，当然这部分尝试来源于兴趣，你可以只是用默认的 bash shell。</p>\n<h1>终端模拟器</h1>\n<p>和自定义 shell 一样，花点时间选择适合您的 <strong>终端模拟器</strong> 并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间 <a href=\"https://anarc.at/blog/2018-04-12-terminal-emulators-1/\">比较</a> 的信息）</p>\n<p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p>\n<ul>\n<li>字体选择</li>\n<li>彩色主题</li>\n<li>快捷键</li>\n<li>标签页/面板支持</li>\n<li>回退配置</li>\n<li>性能（像 <a href=\"https://github.com/jwilm/alacritty\">Alacritty</a> 或者 <a href=\"https://sw.kovidgoyal.net/kitty/\">kitty</a> 这种比较新的终端，它们支持 GPU 加速）。</li>\n</ul>\n<h2>任务控制</h2>\n<ol>\n<li><p>我们可以使用类似 <code>ps aux | grep</code> 这样的命令来获取任务的 pid ，然后您可以基于 pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 <code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code> 将其切换到后台并使用 <code>bg</code> 来继续允许它。现在，使用 <a href=\"https://www.runoob.com/linux/linux-comm-pgrep.html\"><code>pgrep</code></a> 来查找 pid 并使用 <a href=\"https://www.runoob.com/linux/linux-comm-pkill.html\"><code>pkill</code></a> 结束进程而不需要手动输入 pid。(提示：: 使用 <code>-af</code> 标记)。</p>\n</li>\n<li><p>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？在这个练习中，我们使用 <code>sleep 60 &amp;</code> 作为先执行的程序。一种方法是使用 <a href=\"https://www.runoob.com/linux/linux-comm-wait.html\"><code>wait</code></a> 命令。尝试启动这个休眠命令，然后待其结束后再执行 <code>ls</code> 命令。</p>\n<p> 但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <code>wait</code> 只能对子进程起作用。之前我们没有提过的一个特性是，<code>kill</code> 命令成功退出时其状态码为 0 ，其他状态则是非 0。<code>kill -0</code> 则不会发送信号，但是会在进程不存在时返回一个不为 0 的状态码。请编写一个 bash 函数 <code>pidwait</code> ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 <code>sleep</code> 来避免浪费 CPU 性能。</p>\n</li>\n</ol>\n<h2>别名</h2>\n<ol>\n<li>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将 <code>cd</code> 输入为 <code>dc</code> 时也能正确执行。</li>\n<li>执行 <code>history | awk &#39;{$1=&quot;&quot;;print substr($0,2)}&#39; | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用 <code>history 1</code> 替换 <code>history</code>。</li>\n</ol>\n<h2>配置文件</h2>\n<p>让我们帮助您进一步学习配置文件：</p>\n<ol>\n<li>为您的配置文件新建一个文件夹，并设置好版本控制</li>\n<li>在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <code>$PS1</code> 开始）。</li>\n<li>建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个 shell 脚本对每个文件使用 <code>ln -s</code>，也可以使用 <a href=\"https://wiki.archlinuxcn.org/zh-cn/Dotfiles\">专用工具</a></li>\n<li>在新的虚拟机上测试该安装脚本。</li>\n<li>将您现有的所有配置文件移动到项目仓库里。</li>\n<li>将项目发布到 GitHub。</li>\n</ol>\n<h2>远端设备</h2>\n<p>进行下面的练习需要您先安装一个 Linux 虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考 <a href=\"https://www.cnblogs.com/aixxjl/p/18854590\">这篇教程</a> 来进行安装，也可以使用<code>Wsl</code>或者<code>云服务器</code>，当然如果你已经学习使用过<code>云服务器</code>这些应该只是基础操作。</p>\n<ol>\n<li>前往 <code>~/.ssh/</code> 并查看是否已经存在 SSH 密钥对。如果不存在，请使用 <code>ssh-keygen -o -a 100 -t ed25519</code> 来创建一个。建议为密钥设置密码然后使用 <code>ssh-agent</code>。更多可以参考上面的文章。</li>\n<li>在 <code>.ssh/config</code> 加入下面内容：</li>\n</ol>\n<pre><code class=\"language-bash\">Host vm\n    User username_goes_here\n    HostName ip_goes_here\n    IdentityFile ~/.ssh/id_ed25519\n    LocalForward 9999 localhost:8888\n</code></pre>\n<ol start=\"3\">\n<li>使用 <code>ssh-copy-id vm</code> 将您的 ssh 密钥拷贝到服务器。</li>\n<li>使用 <code>python -m http.server 8888</code> 在您的虚拟机中启动一个 Web 服务器并通过本机的 <code>http://localhost:9999</code> 访问虚拟机上的 Web 服务器</li>\n<li>使用 <code>sudo vim /etc/ssh/sshd_config</code> 编辑 SSH 服务器配置，通过修改 <code>PasswordAuthentication</code> 的值来禁用密码验证。通过修改 <code>PermitRootLogin</code> 的值来禁用 root 登录。然后使用 <code>sudo service sshd restart</code> 重启 <code>ssh</code> 服务器，然后重新尝试。</li>\n<li>(尝试) 在虚拟机中安装 <a href=\"https://mosh.org/\"><code>mosh</code></a> 并启动连接。然后断开服务器/虚拟机的网络适配器。mosh 可以恢复连接吗？</li>\n<li>(尝试) 查看 <code>ssh</code> 的 <code>-N</code> 和 <code>-f</code> 选项的作用，找出在后台进行端口转发的命令是什么？</li>\n</ol>\n<h1>Shell 脚本</h1>\n<p>到目前为止，我们已经学习了如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>\n<p>shell 脚本的复杂性进一步提高。</p>\n<p>大多数 shell 都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell 脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p>\n<p>在 bash 中为变量赋值的语法是 <code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。\n需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序 <code>foo</code> 并将 <code>=</code> 和 <code>bar</code> 作为参数。\n总的来说，在 shell 脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>\n<p>Bash 中的字符串通过 <code>&#39;</code> 和 <code>&quot;</code> 分隔符来定义，但是它们的含义并不相同。以 <code>&#39;</code> 定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code> 定义的字符串会将变量值进行替换。</p>\n<pre><code class=\"language-bash\">foo=bar\necho &quot;$foo&quot;\n# 打印 bar\necho &#39;$foo&#39;\n# 打印 $foo\n</code></pre>\n<p>和其他大多数的编程语言一样，<code>bash</code> 也支持 <code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地，\n <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用 <code>cd</code> 进入该文件夹。</p>\n<pre><code class=\"language-bash\">mcd () {\n    mkdir -p &quot;$1&quot;\n    cd &quot;$1&quot;\n}\n</code></pre>\n<p>这里 <code>$1</code> 是脚本的第一个参数。与其他脚本语言不同的是，bash 使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举了其中一些变量，更完整的列表可以参考 <a href=\"https://www.tldp.org/LDP/abs/html/special-chars.html\">这里</a>。</p>\n<ul>\n<li><code>$0</code> - 脚本名</li>\n<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>\n<li><code>$@</code> - 所有参数</li>\n<li><code>$#</code> - 参数个数</li>\n<li><code>$?</code> - 前一个命令的返回值</li>\n<li><code>$$</code> - 当前脚本的进程识别码</li>\n<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code> 再尝试一次。</li>\n<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>\n</ul>\n<p>命令通常使用 <code>STDOUT</code> 来返回输出值，使用 <code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。\n返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值 0 表示正常执行，其他所有非 0 的返回值都表示有错误发生。</p>\n<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于 <a href=\"https://en.wikipedia.org/wiki/Short-circuit_evaluation\">短路运算符</a>（short-circuiting） 同一行的多个命令可以用 <code>;</code> 分隔。程序 <code>true</code> 的返回码永远是 <code>0</code>，<code>false</code> 的返回码永远是 <code>1</code>。让我们看几个例子</p>\n<pre><code class=\"language-bash\">false || echo &quot;Oops, fail&quot;\n# Oops, fail\n\ntrue || echo &quot;Will not be printed&quot;\n#\n\ntrue &amp;&amp; echo &quot;Things went well&quot;\n# Things went well\n\nfalse &amp;&amp; echo &quot;Will not be printed&quot;\n#\n\nfalse ; echo &quot;This will always run&quot;\n# This will always run\n</code></pre>\n<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p>\n<p>当您通过 <code>$( CMD )</code> 这样的方式来执行 <code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN 传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>\n<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n\necho &quot;Starting program at $(date)&quot; # date会被替换成日期和时间\n\necho &quot;Running program $0 with $# arguments with pid $$&quot;\n\nfor file in &quot;$@&quot;; do\n    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null\n    # 如果模式没有找到，则grep退出状态为 1\n    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息\n    if [[ $? -ne 0 ]]; then\n        echo &quot;File $file does not have any foobar, adding one&quot;\n        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;\n    fi\ndone\n</code></pre>\n<p>在条件语句中，我们比较 <code>$?</code> 是否等于 0。\nBash 实现了许多类似的比较操作，您可以查看 <a href=\"https://man7.org/linux/man-pages/man1/test.1.html\"><code>test 手册</code></a>。\n在 bash 中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见 <a href=\"http://mywiki.wooledge.org/BashFAQ/031\">这里</a>。</p>\n<p>当执行脚本时，我们经常需要提供形式类似的参数。bash 使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为 shell 的 <em>通配</em>（<em>globbing</em>）</p>\n<ul>\n<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件 <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code> 这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而 <code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。</li>\n<li>花括号 <code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>\n</ul>\n<pre><code class=\"language-bash\">convert image.{png,jpg}\n# 会展开为\nconvert image.png image.jpg\n\ncp /path/to/project/{foo,bar,baz}.sh /newpath\n# 会展开为\ncp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath\n\n# 也可以结合通配使用\nmv *{.py,.sh} folder\n# 会移动所有 *.py 和 *.sh 文件\n\nmkdir foo bar\n\n# 下面命令会创建 foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h 这些文件\ntouch {foo,bar}/{a..h}\ntouch foo/x bar/y\n# 比较文件夹 foo 和 bar 中包含文件的不同\ndiff &lt;(ls foo) &lt;(ls bar)\n# 输出\n# &lt; x\n# ---\n# &gt; y\n</code></pre>\n<!-- Lastly, pipes `|` are a core feature of scripting. Pipes connect one program's output to the next program's input. We will cover them more in detail in the data wrangling lecture. -->\n\n<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href=\"https://github.com/koalaman/shellcheck\">shellcheck</a> 这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p>\n<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>\n<pre><code class=\"language-python\">#!/usr/local/bin/python\nimport sys\nfor arg in reversed(sys.argv[1:]):\n    print(arg)\n</code></pre>\n<p>内核知道去用 python 解释器而不是 shell 命令来运行这段脚本，是因为脚本的开头第一行的 <a href=\"https://en.wikipedia.org/wiki/Shebang_(Unix)\">shebang</a>。</p>\n<p>在 <code>shebang</code> 行中使用 <a href=\"https://man7.org/linux/man-pages/man1/env.1.html\"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的 <code>PATH</code> 环境变量来进行定位。\n例如，使用了 <code>env</code> 的 shebang 看上去是这样的 <code>#!/usr/bin/env python</code>。</p>\n<p>shell 函数和脚本有如下一些不同点：</p>\n<ul>\n<li>函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>\n<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>\n<li>函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。使用 <a href=\"https://man7.org/linux/man-pages/man1/export.1p.html\"><code>export</code></a> 导出的环境变量会以传值的方式传递给脚本。</li>\n<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。</li>\n</ul>\n<h1>Shell 工具</h1>\n<h2>查看命令如何使用</h2>\n<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？\n一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>\n<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加 <code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用 <code>man</code> 命令。<a href=\"https://man7.org/linux/man-pages/man1/man.1.html\"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>\n<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的 <code>-i</code>。\n事实上，目前我们给出的所有命令的说明链接，都是网页版的 Linux 命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>\n<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。\n<a href=\"https://tldr.sh/\">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>\n<p>例如，在 tldr 上搜索 <a href=\"https://tldr.ostera.io/tar\"><code>tar</code></a> 的用法。</p>\n<h2>查找文件</h2>\n<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类 UNIX 系统都包含一个名为 <a href=\"https://man7.org/linux/man-pages/man1/find.1.html\"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code> 命令会递归地搜索符合条件的文件，例如：</p>\n<pre><code class=\"language-bash\"># 查找所有名称为src的文件夹\nfind . -name src -type d\n# 查找所有文件夹路径中包含test的python文件\nfind . -path &#39;*/test/*.py&#39; -type f\n# 查找前一天修改的所有文件\nfind . -mtime -1\n# 查找所有大小在500k至10M的tar.gz文件\nfind . -size +500k -size -10M -name &#39;*.tar.gz&#39;\n</code></pre>\n<p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>\n<pre><code class=\"language-bash\"># 删除全部扩展名为.tmp 的文件\nfind . -name &#39;*.tmp&#39; -exec rm {} \\;\n# 查找全部的 PNG 文件并将其转换为 JPG\nfind . -name &#39;*.png&#39; -exec magick {} {}.jpg \\;\n</code></pre>\n<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name &#39;*PATTERN*&#39;</code> (如果您希望模式匹配时是不区分大小写，可以使用 <code>-iname</code> 选项）</p>\n<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。\n记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>\n<p>例如，<a href=\"https://github.com/sharkdp/fd\"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为 <code>find</code> 的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持 unicode 并且我认为它的语法更符合直觉。以模式 <code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>\n<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>\n<p>这就要靠 <a href=\"https://man7.org/linux/man-pages/man1/locate.1.html\"><code>locate</code></a> 了。\n<code>locate</code> 使用一个由 <a href=\"https://man7.org/linux/man-pages/man1/updatedb.1.html\"><code>updatedb</code></a> 负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href=\"https://man7.org/linux/man-pages/man8/cron.8.html\"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code> 则只能通过文件名。 <a href=\"https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other\">这里</a> 有一个更详细的对比。</p>\n<h2>查找代码</h2>\n<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>\n<p>为了实现这一点，很多类 UNIX 的系统都提供了 <a href=\"https://man7.org/linux/man-pages/man1/grep.1.html\"><code>grep</code></a> 命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的 shell 工具，我们会在后续的数据清理课程中深入的探讨它。</p>\n<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>\n<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略 <code>.git</code> 文件夹，使用多 CPU 等等。</p>\n<p>因此也出现了很多它的替代品，包括 <a href=\"https://beyondgrep.com/\">ack</a>, <a href=\"https://github.com/ggreer/the_silver_searcher\">ag</a> 和 <a href=\"https://github.com/BurntSushi/ripgrep\">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>\n<pre><code class=\"language-bash\"># 查找所有使用了 requests 库的文件\nrg -t py &#39;import requests&#39;\n# 查找所有没有写 shebang 的文件（包含隐藏文件）\nrg -u --files-without-match &quot;^#\\!&quot;\n# 查找所有的foo字符串，并打印其之后的5行\nrg foo -A 5\n# 打印匹配的统计信息（匹配的行和文件的数量）\nrg --stats PATTERN\n</code></pre>\n<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>\n<h2>查找 shell 命令</h2>\n<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用 shell 的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>\n<p><code>history</code> 命令允许您以程序员的方式来访问 shell 中输入的历史命令。这个命令会在标准输出中打印 shell 中的历史命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。\n<code>history | grep find</code> 会打印包含 find 子串的命令。</p>\n<p>对于大多数的 shell 来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>\n<p>反复按下就会在所有搜索结果中循环。在 <a href=\"https://github.com/zsh-users/zsh-history-substring-search\">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>\n<p><code>Ctrl+R</code> 可以配合 <a href=\"https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r\">fzf</a> 使用。<code>fzf</code> 是一个通用的模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>\n<p>另外一个和历史命令相关的技巧我喜欢称之为 <strong>基于历史的自动补全</strong>。\n这一特性最初是由 <a href=\"https://fishshell.com/\">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前的 shell 命令进行补全。这一功能在 <a href=\"https://github.com/zsh-users/zsh-autosuggestions\">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>\n<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。\n为此你需要在 <code>.bashrc</code> 中添加 <code>HISTCONTROL=ignorespace</code> 或者向 <code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。\n如果你不小心忘了在前面加空格，可以通过编辑 <code>.bash_history</code> 或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>\n<h2>文件夹导航</h2>\n<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href=\"https://man7.org/linux/man-pages/man1/ln.1.html\">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>\n<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href=\"https://github.com/clvv/fasd\"><code>fasd</code></a> 和 <a href=\"https://github.com/wting/autojump\">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>\n<p>Fasd 基于 <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm\"><em>frecency</em> </a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用 <code>j cool</code> 代替即可。</p>\n<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href=\"https://linux.die.net/man/1/tree\"><code>tree</code></a>, <a href=\"https://github.com/Canop/broot\"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href=\"https://github.com/jarun/nnn\"><code>nnn</code></a> 或 <a href=\"https://github.com/ranger/ranger\"><code>ranger</code></a>。</p>\n"
    }
  ],
  "tags": {
    "计算机基础": [
      "command-line",
      "Git使用入门",
      "markdown",
      "Python_Manage",
      "Shell",
      "Shell_tool"
    ]
  }
}